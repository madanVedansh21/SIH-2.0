const Test = require("../models/test.model");
const Transformer = require("../models/transformer.model");
const mlClient = require("./ml.client");

async function createTestRecord({
  transformerId,
  fileRecord,
  parsedData,
  testDate,
  uploaderId,
  uploadedFile,
}) {
  const test = new Test({
    transformer: transformerId,
    filename: fileRecord.filename,
    originalName: fileRecord.originalname,
    // Note: files are not stored on disk in memory mode; no uploadPath
    uploadPath: null,
    fileType: fileRecord.mimetype || fileRecord.type,
    testDate: testDate || new Date(),
    // If sending file directly to ML, we don't need to persist rawData; otherwise keep parsedData
    rawData: parsedData || {},
    status: "processing",
  });
  await test.save();
  // Link this test to the transformer document for easy lookup
  try {
    await Transformer.findByIdAndUpdate(
      transformerId,
      { $addToSet: { tests: test._id } },
      { new: false }
    );
  } catch (linkErr) {
    // Non-fatal: proceed even if linking fails
  }
  // send to ML model asynchronously
  const mlPromise = uploadedFile
    ? mlClient.sendFile(uploadedFile, test._id)
    : mlClient.send(parsedData, test._id);

  mlPromise
    .then(async (inference) => {
      test.analysisSummary = inference.summary || {};
      // Store full structured AI result if provided by ML API
      if (inference.result) {
        test.aiResult = inference.result;
      } else if (inference.diagnosis || inference.recommendations) {
        // Some APIs may return top-level properties already in the requested shape
        test.aiResult = {
          diagnosis: inference.diagnosis || {},
          recommendations: inference.recommendations || {},
        };
      }
      test.status = "completed";
      test.mlRequestId = inference.requestId || null;
      test.mlResponse = inference || {};
      test.processedAt = new Date();
      await test.save();

      // alerts are generated by ML but this deployment does not store alerts in DB
    })
    .catch(async (err) => {
      test.status = "failed";
      test.analysisSummary = { error: err.message };
      test.mlResponse = { error: err.message };
      test.processedAt = new Date();
      await test.save();
    });

  return test;
}

async function listTests(transformerId) {
  return Test.find({ transformer: transformerId })
    .sort({ testDate: -1 })
    .lean();
}

async function getTestDetails(testId) {
  const test = await Test.findById(testId).lean();
  // prepare graph data (placeholder)
  const graphData = {
    points: test.rawData?.points || [],
    meta: test.analysisSummary || {},
  };
  return { test, graphData };
}

async function setApproval(testId, approved, approverId, comment) {
  const update = {};
  if (approved) {
    update.approved = true;
    update.approvedBy = approverId;
    update.approvedAt = new Date();
    // optionally store comment in analysisSummary.approvalComment
    if (comment) update["analysisSummary.approvalComment"] = comment;
  } else {
    update.approved = false;
    update.approvedBy = null;
    update.approvedAt = null;
    if (comment) update["analysisSummary.unapprovalReason"] = comment;
  }
  const updated = await Test.findByIdAndUpdate(testId, update, {
    new: true,
  }).lean();
  return updated;
}

async function deleteTestAndUnlink(testId) {
  // Find the test to get transformer reference first
  const test = await Test.findById(testId).lean();
  if (!test) return null;
  // Delete test
  await Test.deleteOne({ _id: testId });
  // Unlink from transformer.tests
  try {
    await Transformer.findByIdAndUpdate(test.transformer, {
      $pull: { tests: test._id },
    });
  } catch (e) {
    // non-fatal
  }
  return { ok: true };
}

module.exports = {
  createTestRecord,
  listTests,
  getTestDetails,
  setApproval,
  deleteTestAndUnlink,
};
